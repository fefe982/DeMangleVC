# Special symbols generated by VC++

## `vftable`

`??_7***6B@`

``const {0}::`vftable'``

`??_7***6B***@`

``const {0}::`vftable'{for `{1}'}``

The virtual function table. Collection of addresses for the final overload of all the virtual functions within a class.

If there is multiple inheritance, and there is a need to generate a vftable for each of the bases, there will be a "for" part in this symbol, naming each of the bases needed.

## `vbtable`

`??_8***7B@`

``const {0}::`vbtable'``

`??_8***7B***@`

``const {0}::`vbtable'{for `{1}'}``

The virtual base table, contains informaion for virtual bases.

If there is multiple inheritance, the vbtable may be generated for each of the virtual base. It will be demangled with a for part in the "vbtable".

## `vcall`

`??_9***$B3AE`

``[thunk]: __thiscall vbase::`vcall'{4,{flat}}' }'``

It is a fucntion (thunk) generated for pointer to virtual member function.

In C++, the final overrider is required to be called when the function is virtual. So, pointer to virtual member function is different from pointer to non-virtual member function, as it must find the final overrider first. A `vcall` thunk is generated to do this.

The number part in the `vcall` output seems to be an offset in the vftable. The meaning of the `flat` part is unknown, and no other alternative has been seen.

## `typeof`

Haven't found a real piece of code that would generate this symbol.

## `local static guard`

In C++, static variable are only initialized once, and must be thread safe. So usually there is a "guard" to achieve this, preventing multiple initializaiton. The special variab seems to be of this use.

However, I cannot produce this symbol now. Instead, "noraml" local variables with the special names `$TSS0`, `$TSS1` , etc., is used.

## `vbase destructor`

`??_D***UAE@XZ`

``public: void __thiscall {0}::`vbase destructor'(void)``

Generated destructor wrapper for classes with virtual bases.

For classes which has virtual bases, the "normal" destructor function generated by the compiler will not destruct the virtural base, as the virtual base may be shared along the inheritance chain. Instead, for each most derived class, a `vbase destructor` is generated, in which the destrutors of the virtural bases are called, along with the normal destructor of the class.

## `vector deleting destructor`

`??_E***QAEPAXI@Z`

``public: void * __thiscall {0}::`vector deleting destructor'(unsigned int)``

Generated function for `delete[]` expression, and can be put into the `vftable` if the destructor is virtual.

It calls the destructors of every element, then calls `operator delete[]` or `operator delete` to release the memory.

The parameter is a flag which determines where to destruct one or all elementer, and whether to call `operator delete` or `operator delete[]`. The flas is set according to how the function is called. For example, for `delete[]`, all are deleted and `operator delete[]` is used. When it is called from the `vftable` by `delete`, `operator delete` is used.

## `default constructor closure`

`??_F***QAEXXZ`

``void __thiscall {0}::`default constructor closure'(void)``

Generated function that takes no parameter, and wraps a default constructor whose paramters all has default value.

The default constructor in C++ does not have any parameters, or all paramter has a default value.
In the latter case, when a default constructor with no parameters is needed by the compiler, a `default constructor closure` is generated to wrap up the original constructor.

## `scalar deleting destructor`

`??_G***UAEPAXI@Z`

``public: void * __thiscall {0}::`scalar deleting destructor'(unsigned int)``

Generated wrap function for `delete` expresion or explicte destructor call, calls destructor and (optionally) `operator delete`.

The flag parameter controls where `operator delete` should be called.

## `vector constructor iterator`

`??_H@YGXPAXIIP6EPAX0@Z@Z`

``void __stdcall `vector constructor iterator'(void *,unsigned int,int,void * (__thiscall*)(void *))``

Global function to construct an array of class objects.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor

## `vector destructor iterator`

`??_I@YGXPAXIIP6EX0@Z@Z`

``void __stdcall `vector destructor iterator'(void *,unsigned int,unsigned int,void (__thiscall *)(void *))``

Global function to destruct an array of class objects.

paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the destructor

## `vector vbase constructor iterator`

`??_J@YGXPAXIIP6EPAX0@Z@Z`

``void __stdcall `vector vbase constructor iterator'(void *,unsigned int,unsigned int,void * (__thiscall *)(void *))``

Global function to construct an array of class objects with virtual bases. Genterated constructor function for classes with virtual bases has a hidden paramter `_$initVBases$`, which controls where the virtual base should be initialized in the contrusctor. So the iterator function is different from `vector constructor iterator`.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `unsigned int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor

## `virtual displacement map`

`??_K***$C***`

``{0}::`virtual displacement map'{for {1}}``

It is helper structure which helps casting between pointer to member functions in the two classes. Usually multiple inheritance / virtual function / virtual bases are involved.

## `eh vector constructor iterator`

`??_L@YGXPAXIIP6EX0@Z1@Z`

``void __stdcall `eh vector constructor iterator'(void *,unsigned int,int,void (__thiscall *)(void *),void (__thiscall *)(void *))``

Global function to construct an array of class objects, with execption handling.
paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void (__thiscall *)(void *)`: pointer to the constructor
5. `void (__thiscall *)(void *)`: pointer to the destructor

## `eh vector destructor iterator`

`??_M@YGXPAXIIP6EX0@Z@Z`

``void __stdcall `eh vector destructor iterator'(void *,unsigned int,int,void (__thiscall *)(void *))``

Global function to destruct an array of class objects, with exception handling

paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the destructor

## `eh vector vbase constructor iterator`

`??_N@YGXPAXIIP6EX0@Z1@Z`

``void __stdcall `eh vector vbase constructor iterator'(void *,unsigned int,int,void (__thiscall*)(void *),void (__thiscall*)(void *))``

Global function to construct an array of class objects with virtual bases, with exception handling. Genterated constructor function for classes with virtual bases has a hidden paramter `_$initVBases$`, which controls where the virtual base should be initialized in the contrusctor. So the iterator function is different from `vector constructor iterator`.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `unsigned int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor
