# Special symbols generated by VC++

## `vftable`

`??_7vbase@@6B@`

``const vbase::`vftable'``

`??_7three@@6Bone@@@`

``const three::`vftable'{for `one'}``

The virtual function table. The first entry is the `RTTI Complete Object Locator`, and the rest is the collection of addresses for the final overload of all the virtual functions within a class.

If there is multiple inheritance, and there is a need to generate a vftable for each of the bases, there will be a "for" part in this symbol, naming each of the bases needed.

## `vbtable`

`??_8X@@7B@`

``const X::`vbtable'``

`??_8three@@7Bone@@@`

``const three::`vbtable'{for `one'}``

The virtual base table, contains informaion for virtual bases.

If there is multiple inheritance, the vbtable may be generated for each of the virtual base. It will be demangled with a for part in the "vbtable".

## `vcall`

`??_9vbase@@$B3AE`

``[thunk]: __thiscall vbase::`vcall'{4,{flat}}' }'``

It is a fucntion (thunk) generated for pointer to virtual member function.

In C++, the final overrider is required to be called when the function is virtual. So, pointer to virtual member function is different from pointer to non-virtual member function, as it must find the final overrider first. A `vcall` thunk is generated to do this.

The number part in the `vcall` output seems to be an offset in the vftable. The meaning of the `flat` part is unknown, and no other alternative has been seen.

## `typeof`

Haven't found a real piece of code that would generate this symbol.

## `local static guard`

In C++, static variable are only initialized once, and must be thread safe. So usually there is a "guard" to achieve this, preventing multiple initializaiton. The special variab seems to be of this use.

However, I cannot produce this symbol now. Instead, "noraml" local variables with the special names `$TSS0`, `$TSS1` , etc., is used.

## `vbase destructor`

`??_DAA@@QAEXXZ`

``public: void __thiscall AA::`vbase destructor'(void)``

Generated destructor wrapper for classes with virtual bases.

For classes which has virtual bases, the "normal" destructor function generated by the compiler will not destruct the virtural base, as the virtual base may be shared along the inheritance chain. Instead, for each most derived class, a `vbase destructor` is generated, in which the destrutors of the virtural bases are called, along with the normal destructor of the class.

## `vector deleting destructor`

`??_Efour@@UAEPAXI@Z`

``public: virtual void * __thiscall four::`vector deleting destructor'(unsigned int)``

`??_Efour@@$4PPPPPPPM@A@AEPAXI@Z`

``[thunk]:public: virtual void * __thiscall four::`vector deleting destructor'`vtordisp{-4,0}' (unsigned int)``

Generated function for `delete[]` expression, and can be put into the `vftable` if the destructor is virtual. When it is put into the `vftable`, it may need a thunk ot adjust the `this` pointer. The thunk is the second version of the example above.

It calls the destructors of every element, then calls `operator delete[]` or `operator delete` to release the memory.

The parameter is a flag which determines where to destruct one or all elementer, and whether to call `operator delete` or `operator delete[]`. The flas is set according to how the function is called. For example, for `delete[]`, all are deleted and `operator delete[]` is used. When it is called from the `vftable` by `delete`, `operator delete` is used.

## `default constructor closure`

`??_Fvbase@@QAEXXZ`

``public: void __thiscall vbase::`default constructor closure'(void)``

Generated function that takes no parameter, and wraps a default constructor whose paramters all has default value.

The default constructor in C++ does not have any parameters, or all paramter has a default value.
In the latter case, when a default constructor with no parameters is needed by the compiler, a `default constructor closure` is generated to wrap up the original constructor.

## `scalar deleting destructor`

`??_Gtwo@@UAEPAXI@Z`

``public: virtual void * __thiscall two::`scalar deleting destructor'(unsigned int)``

Generated wrap function for `delete` expresion or explicte destructor call, calls destructor and (optionally) `operator delete`.

The flag parameter controls where `operator delete` should be called.

## `vector constructor iterator`

`??_H@YGXPAXIIP6EPAX0@Z@Z`

``void __stdcall `vector constructor iterator'(void *,unsigned int,int,void * (__thiscall*)(void *))``

Library function to construct an array of class objects.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor

## `vector destructor iterator`

`??_I@YGXPAXIIP6EX0@Z@Z`

``void __stdcall `vector destructor iterator'(void *,unsigned int,unsigned int,void (__thiscall *)(void *))``

Library function to destruct an array of class objects.

paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the destructor

## `vector vbase constructor iterator`

`??_J@YGXPAXIIP6EPAX0@Z@Z`

``void __stdcall `vector vbase constructor iterator'(void *,unsigned int,unsigned int,void * (__thiscall *)(void *))``

Library function to construct an array of class objects with virtual bases. Genterated constructor function for classes with virtual bases has a hidden paramter `_$initVBases$`, which controls where the virtual base should be initialized in the contrusctor. So the iterator function is different from `vector constructor iterator`.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `unsigned int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor

## `virtual displacement map`

`??_KB@x@@$CC@1@`

``x::B::`virtual displacement map'{for x::C}``

It is helper structure which helps casting between pointer to member functions in the two classes. Usually multiple inheritance / virtual function / virtual bases are involved.

## `eh vector constructor iterator`

`??_L@YGXPAXIIP6EX0@Z1@Z`

``void __stdcall `eh vector constructor iterator'(void *,unsigned int,int,void (__thiscall *)(void *),void (__thiscall *)(void *))``

Library function to construct an array of class objects, with execption handling.
paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void (__thiscall *)(void *)`: pointer to the constructor
5. `void (__thiscall *)(void *)`: pointer to the destructor

## `eh vector destructor iterator`

`??_M@YGXPAXIIP6EX0@Z@Z`

``void __stdcall `eh vector destructor iterator'(void *,unsigned int,int,void (__thiscall *)(void *))``

Library function to destruct an array of class objects, with exception handling

paramters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the destructor

## `eh vector vbase constructor iterator`

`??_N@YGXPAXIIP6EX0@Z1@Z`

``void __stdcall `eh vector vbase constructor iterator'(void *,unsigned int,int,void (__thiscall*)(void *),void (__thiscall*)(void *))``

Library function to construct an array of class objects with virtual bases, with exception handling. Genterated constructor function for classes with virtual bases has a hidden paramter `_$initVBases$`, which controls where the virtual base should be initialized in the contrusctor. So the iterator function is different from `vector constructor iterator`.

parameters:

1. `void *`: starting address of the array
2. `unsigned int`: size of one object
3. `unsigned int`: number of objects
4. `void * (__thiscall*)(void *)`: pointer to the constructor

## `copy constructor closure`

`??_OTestClassA@@QAEXAAV0@@Z`

``public: void __thiscall TestClassA::`copy constructor closure'(class TestClassA &)``

Generated copy contructor, and wraps the actually which has more parameters, but all but the first have default values.

The copy constructor in C++ has only one parameter, or all but the first paramter have default argument.
In the latter case, when a copy constructor with only one parameters is needed by the compiler, a `copy constructor closure` is generated to wrap up the original constructor.

## `RTTI Type Descriptor`

`??_R0?AUbase@@@8`

``struct base `RTTI Type Descriptor'``

A struct (of type `std::type_info`) that contains the runtime type information.

## `RTTI Base Class Descriptor`

`??_R1A@?0A@EA@four@@8`

``four::`RTTI Base Class Descriptor at (0,-1,0,64)'``

A structure that describe a base class object. The data contains `RTTI Type Descriptor` of the base class, number of bases that base has, offset of the base class object (`vftable`), an atribute, and the `RTTI Class Hierarchy Descriptor`.

The numbers mangled in the name is the offset (first three numbers) and attribute.

## `RTTI Base Class Array`

`??_R2four@@8`

``four::`RTTI Base Class Array'``

An array of `RTTI Base Class Descriptor` for all (direct and inderect) base classes. The first entry is the class itself.

## `RTTI Class Hierarchy Descriptor`

`??_R3four@@8`

``four::`RTTI Class Hierarchy Descriptor'``

A structure describes class dierarchy. It contains attribute that shows multiple / virtual inheritance, count of bases classes (including self), and `RTTI Base Class Array`.

## `RTTI Complete Object Locator`

`??_R4base@@6B@`

``const base::`RTTI Complete Object Locator'``

`??_R4two@@6Bvbase@@@`

``const two::`RTTI Complete Object Locator'{for `vbase'}``

This structure contains information about the offset of the class within the complete class object, and the `RTTI Type Descriptor`, `RTTI Class Hierarchy Descriptor` for the compelete object.

## `local vftable`

`??_SIMPClass@@6B@`

``const IMPClass::`local vftable'``

Used to replace the `vftable` for object of `dllimport`ed class created by `new`.

The `vector deleting destructor` is put into the `vftable` if the destructor is virtual, can it calls `operator delete`. However, for `dllimport`ed classes, the `operator delete` inside the DLL (which is called by the `vector deleting destructor` in the DLL) may not be the same with the one in the exe. It may not match the `operator new` in the EXE, which may cause problems. To resolve this, for these classes, a `local vftable` is generated to replace the original `vftable` in the object, after normal object construct in the EXE. In the `local vftable`, the destructor calls the `operator delete` in the EXE.

Details see [here](https://groups.google.com/forum/#!msg/microsoft.public.vc.language/atSh_2VSc2w/EgJ3r_7OzVUJ).

## `local vftable constructor closure`

`??_TIMPClass@@QAEXXZ`

``public: void __thiscall IMPClass::`local vftable constructor closure'(void)``

It is used to wrap up the normal construct steps and the replacement of `local vftable`.

## `placement delete closure` `placement delete[] closure`

Need more information.

## `eh vector copy constructor iterator`

`??__C@YGXPAX0IIP6EX00@ZP6EX0@Z@Z`

``void __stdcall `eh vector copy constructor iterator'(void *,void *,unsigned int,unsigned int,void (__thiscall *)(void *,void *),void (__thiscall *)(void *))``

Library function to copy construct an array of class objects.

Parameter:

1. `void *`: Destination array address
2. `void *`: Source array address
3. `unsigned int`: size of an object
4. `unsigned int`: number of objects in the array
5. `void (__thiscall *)(void *,void *)`: copy constructor of the class
6. `void (__thiscall *)(void *)`: destructor of the class

## `eh vector vbase copy constructor iterator`

`??__D@YGXPAX0IIP6EX00@ZP6EX0@Z@Z`

``void __stdcall `eh vector vbase copy constructor iterator'(void *,void *,unsigned int,unsigned int,void (__thiscall *)(void *,void *),void (__thiscall *)(void *))``

Library function to copy construct an array of class objects, for class with virtual bases.

Parameter:

1. `void *`: Destination array address
2. `void *`: Source array address
3. `unsigned int`: size of an object
4. `unsigned int`: number of objects in the array
5. `void (__thiscall *)(void *,void *)`: copy constructor of the class
6. `void (__thiscall *)(void *)`: destructor of the class

## `vector copy constructor iterator`

`??__G@YGXPAX0IIP6EPAX00@Z@Z`

``void __stdcall `vector copy constructor iterator'(void *,void *,unsigned int,unsigned int,void * (__thiscall *)(void *,void *))``

Library function to copy construct an array of class objects, without exception handling

Parameter:

1. `void *`: Destination array address
2. `void *`: Source array address
3. `unsigned int`: size of an object
4. `unsigned int`: number of objects in the array
5. `void (__thiscall *)(void *,void *)`: copy constructor of the class

## `vector vbase copy constructor iterator`

`??__H@YGXPAX0IIP6EPAX00@Z@Z`

``void __stdcall `vector vbase copy constructor iterator'(void *,void *,unsigned int,unsigned int,void * (__thiscall *)(void *,void *))``

Library function to copy construct an array of class objects, for class with virtual bases, without exception handling.

Parameter:

1. `void *`: Destination array address
2. `void *`: Source array address
3. `unsigned int`: size of an object
4. `unsigned int`: number of objects in the array
5. `void (__thiscall *)(void *,void *)`: copy constructor of the class
